// package com.example.composite;

// import static org.junit.jupiter.api.Assertions.assertEquals;
// import static org.junit.jupiter.api.Assertions.assertFalse;
// import static org.junit.jupiter.api.Assertions.assertNotEquals;
// import static org.junit.jupiter.api.Assertions.assertNotNull;
// import static org.junit.jupiter.api.Assertions.assertThrows;
// import static org.mockito.ArgumentMatchers.any;
// import static org.mockito.ArgumentMatchers.anyString;
// import static org.mockito.ArgumentMatchers.eq;
// import static org.mockito.Mockito.times;
// import static org.mockito.Mockito.verify;
// import static org.mockito.Mockito.when;

// import java.util.ArrayList;
// import java.util.Collections;
// import java.util.HashSet;
// import java.util.List;
// import java.util.Set;
// import java.util.concurrent.atomic.AtomicReference;

// import org.junit.jupiter.api.Test;
// import org.junit.jupiter.api.extension.ExtendWith;
// import org.springframework.beans.factory.annotation.Autowired;
// import org.springframework.boot.test.context.SpringBootTest;
// import org.springframework.boot.test.mock.mockito.MockBean;
// import org.springframework.boot.test.mock.mockito.SpyBean;
// import org.springframework.http.HttpEntity;
// import org.springframework.http.HttpMethod;
// import org.springframework.http.ResponseEntity;
// import org.springframework.test.context.bean.override.mockito.MockitoBean;
// import org.springframework.test.context.bean.override.mockito.MockitoSpyBean;
// import org.springframework.test.context.junit.jupiter.SpringExtension;
// import org.springframework.transaction.PlatformTransactionManager;
// import org.springframework.transaction.TransactionDefinition;
// import org.springframework.transaction.TransactionTimedOutException;
// import org.springframework.transaction.support.DefaultTransactionDefinition;
// import org.springframework.transaction.support.TransactionSynchronizationManager;
// import org.springframework.transaction.support.TransactionTemplate;
// import org.springframework.web.client.RestTemplate;

// import com.example.composite.config.EndpointRegistry;
// import com.example.composite.exception.CompositeExecutionException;
// import com.example.composite.model.request.CompositeRequest;
// import com.example.composite.model.request.SubRequest;
// import com.example.composite.model.response.CompositeResponse;
// import com.example.composite.service.CompositeService;

// @ExtendWith(SpringExtension.class)
// @SpringBootTest
// class TransactionBoundaryTests {
//     @Autowired
//     private CompositeService compositeService;

//     @MockitoBean
//     private RestTemplate restTemplate;

//     @MockitoBean
//     private EndpointRegistry endpointRegistry;

//     @MockitoSpyBean
//     private PlatformTransactionManager transactionManager;

//     @Autowired
//     private TransactionTemplate transactionTemplate;

//     @Test
//     void shouldMaintainTransactionAcrossAsync() {
//         // Given
//         List<SubRequest> parallelRequests = List.of(
//             SubRequest.builder()
//                 .referenceId("req1")
//                 .url("/api/test1")
//                 .method("POST")
//                 .body("data1")
//                 .build(),
//             SubRequest.builder()
//                 .referenceId("req2")
//                 .url("/api/test2")
//                 .method("POST")
//                 .body("data2")
//                 .build()
//         );

//         when(endpointRegistry.isEndpointAvailable(anyString(), anyString()))
//             .thenReturn(true);

//         // Store transaction IDs from parallel requests
//         Set<String> transactionIds = Collections.synchronizedSet(new HashSet<>());

//         when(restTemplate.exchange(
//             anyString(),
//             eq(HttpMethod.POST),
//             any(HttpEntity.class),
//             eq(Object.class)
//         )).thenAnswer(inv -> {
//             String currentTxId = TransactionSynchronizationManager.getCurrentTransactionName();
//             transactionIds.add(currentTxId);
//             return ResponseEntity.ok().build();
//         });

//         // When
//         CompositeResponse response = compositeService.processRequests(
//             CompositeRequest.builder()
//                 .subRequests(parallelRequests)
//                 .allOrNone(true)
//                 .build()
//         );

//         // Then
//         assertFalse(response.isHasErrors());
//         assertEquals(1, transactionIds.size()); // All requests should share same transaction
//     }

//     @Test
//     void shouldHandleNestedTransactions() {
//         // Given
//         // First request triggers a nested composite request
//         AtomicReference<String> outerTxId = new AtomicReference<>();
//         AtomicReference<String> innerTxId = new AtomicReference<>();

//         SubRequest outerRequest = SubRequest.builder()
//             .referenceId("outer")
//             .url("/api/outer")
//             .method("POST")
//             .body("outer-data")
//             .build();

//         when(endpointRegistry.isEndpointAvailable(anyString(), anyString()))
//             .thenReturn(true);

//         when(restTemplate.exchange(
//             eq("/api/outer"),
//             eq(HttpMethod.POST),
//             any(HttpEntity.class),
//             eq(Object.class)
//         )).thenAnswer(inv -> {
//             outerTxId.set(TransactionSynchronizationManager.getCurrentTransactionName());

//             // Simulate nested composite request
//             SubRequest innerRequest = SubRequest.builder()
//                 .referenceId("inner")
//                 .url("/api/inner")
//                 .method("POST")
//                 .body("inner-data")
//                 .build();

//             CompositeRequest innerComposite = CompositeRequest.builder()
//                 .subRequests(List.of(innerRequest))
//                 .allOrNone(true)
//                 .build();

//             compositeService.processRequests(innerComposite);

//             return ResponseEntity.ok().build();
//         });

//         when(restTemplate.exchange(
//             eq("/api/inner"),
//             eq(HttpMethod.POST),
//             any(HttpEntity.class),
//             eq(Object.class)
//         )).thenAnswer(inv -> {
//             innerTxId.set(TransactionSynchronizationManager.getCurrentTransactionName());
//             return ResponseEntity.ok().build();
//         });

//         // When
//         compositeService.processRequests(
//             CompositeRequest.builder()
//                 .subRequests(List.of(outerRequest))
//                 .allOrNone(true)
//                 .build()
//         );

//         // Then
//         assertNotNull(outerTxId.get());
//         assertNotNull(innerTxId.get());
//         assertEquals(outerTxId.get(), innerTxId.get()); // Should share same transaction
//     }

//     @Test
//     void shouldRollbackPartialChanges() {
//         // Given
//         List<String> executedRequests = new ArrayList<>();

//         List<SubRequest> requests = List.of(
//             SubRequest.builder()
//                 .referenceId("req1")
//                 .url("/api/test1")
//                 .method("POST")
//                 .body("data1")
//                 .build(),
//             SubRequest.builder()
//                 .referenceId("req2")
//                 .url("/api/test2")
//                 .method("POST")
//                 .body("data2")
//                 .build(),
//             SubRequest.builder()
//                 .referenceId("req3")
//                 .url("/api/test3")
//                 .method("POST")
//                 .body("data3")
//                 .build()
//         );

//         when(endpointRegistry.isEndpointAvailable(anyString(), anyString()))
//             .thenReturn(true);

//         // First two requests succeed, third fails
//         when(restTemplate.exchange(
//             anyString(),
//             eq(HttpMethod.POST),
//             any(HttpEntity.class),
//             eq(Object.class)
//         )).thenAnswer(inv -> {
//             String url = inv.getArgument(0);
//             executedRequests.add(url);

//             if (url.contains("test3")) {
//                 throw new RuntimeException("Simulated failure");
//             }

//             return ResponseEntity.ok().build();
//         });

//         // When
//         assertThrows(CompositeExecutionException.class, () ->
//             compositeService.processRequests(
//                 CompositeRequest.builder()
//                     .subRequests(requests)
//                     .allOrNone(true)
//                     .build()
//             )
//         );

//         // Then
//         verify(transactionManager, times(1)).rollback(any());
//         assertEquals(3, executedRequests.size()); // All requests were attempted
//     }

//     @Test
//     void shouldHandleTransactionTimeout() {
//         // Given
//         SubRequest longRequest = SubRequest.builder()
//             .referenceId("long")
//             .url("/api/long")
//             .method("POST")
//             .body("data")
//             .build();

//         when(endpointRegistry.isEndpointAvailable(anyString(), anyString()))
//             .thenReturn(true);

//         when(restTemplate.exchange(
//             eq("/api/long"),
//             eq(HttpMethod.POST),
//             any(HttpEntity.class),
//             eq(Object.class)
//         )).thenAnswer(inv -> {
//             Thread.sleep(2000); // Simulate long-running request
//             return ResponseEntity.ok().build();
//         });

//         // When
//         assertThrows(
//             TransactionTimedOutException.class, 
//             () -> transactionTemplate.execute(status -> {
//                 TransactionDefinition def = 
//                     new DefaultTransactionDefinition(TransactionDefinition.PROPAGATION_REQUIRED);
//                 ((DefaultTransactionDefinition) def).setTimeout(1); // 1 second timeout

//                 return compositeService.processRequests(
//                     CompositeRequest.builder()
//                         .subRequests(List.of(longRequest))
//                         .allOrNone(true)
//                         .build()
//                 );
//             })
//         );

//         // Then
//         verify(transactionManager, times(1)).rollback(any());
//     }

//     @Test
//     void shouldHandleTransactionSuspension() {
//         // Given
//         AtomicReference<String> tx1 = new AtomicReference<>();
//         AtomicReference<String> tx2 = new AtomicReference<>();

//         SubRequest request1 = SubRequest.builder()
//             .referenceId("req1")
//             .url("/api/test1")
//             .method("POST")
//             .body("data1")
//             .build();

//         SubRequest request2 = SubRequest.builder()
//             .referenceId("req2")
//             .url("/api/test2")
//             .method("POST")
//             .body("data2")
//             .build();

//         when(endpointRegistry.isEndpointAvailable(anyString(), anyString()))
//             .thenReturn(true);

//         when(restTemplate.exchange(
//             eq("/api/test1"),
//             eq(HttpMethod.POST),
//             any(HttpEntity.class),
//             eq(Object.class)
//         )).thenAnswer(inv -> {
//             tx1.set(TransactionSynchronizationManager.getCurrentTransactionName());
//             return ResponseEntity.ok().build();
//         });

//         when(restTemplate.exchange(
//             eq("/api/test2"),
//             eq(HttpMethod.POST),
//             any(HttpEntity.class),
//             eq(Object.class)
//         )).thenAnswer(inv -> {
//             tx2.set(TransactionSynchronizationManager.getCurrentTransactionName());
//             return ResponseEntity.ok().build();
//         });

//         // When
//         compositeService.processRequests(
//             CompositeRequest.builder()
//                 .subRequests(List.of(request1))
//                 .allOrNone(true)
//                 .build()
//         );

//         compositeService.processRequests(
//             CompositeRequest.builder()
//                 .subRequests(List.of(request2))
//                 .allOrNone(true)
//                 .build()
//         );

//         // Then
//         assertNotNull(tx1.get());
//         assertNotNull(tx2.get());
//         assertNotEquals(tx1.get(), tx2.get()); // Different transactions
//     }
// }
